from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

from litellm import ChatCompletionRequest


@dataclass
class CodeSnippet:
    """
    Represents a code snippet with its programming language.

    Args:
        language: The programming language identifier (e.g., 'python', 'javascript')
        code: The actual code content
    """

    language: Optional[str]
    filepath: Optional[str]
    code: str

    def __post_init__(self):
        if self.language is not None:
            self.language = self.language.strip().lower()


@dataclass
class PipelineContext:
    code_snippets: List[CodeSnippet] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def add_code_snippet(self, snippet: CodeSnippet):
        self.code_snippets.append(snippet)

    def get_snippets_by_language(self, language: str) -> List[CodeSnippet]:
        return [s for s in self.code_snippets if s.language.lower() == language.lower()]


@dataclass
class PipelineResponse:
    """Response generated by a pipeline step"""

    content: str
    step_name: str  # The name of the pipeline step that generated this response
    model: str  # Taken from the original request's model field


@dataclass
class PipelineResult:
    """
    Represents the result of a pipeline operation.
    Either contains a modified request to continue processing,
    or a response to return to the client.
    """

    request: Optional[ChatCompletionRequest] = None
    response: Optional[PipelineResponse] = None
    context: Optional[PipelineContext] = None
    error_message: Optional[str] = None

    def shortcuts_processing(self) -> bool:
        """Returns True if this result should end pipeline processing"""
        return self.response is not None or self.error_message is not None

    @property
    def success(self) -> bool:
        """Returns True if the pipeline step completed without errors"""
        return self.error_message is None


class PipelineStep(ABC):
    """Base class for all pipeline steps in the processing chain."""

    @property
    @abstractmethod
    def name(self) -> str:
        """
        Returns the name of the pipeline step.

        Returns:
            str: A unique identifier for this pipeline step
        """
        pass

    @staticmethod
    def get_last_user_message(
        request: ChatCompletionRequest,
    ) -> Optional[tuple[str, int]]:
        """
        Get the last user message and its index from the request.

        Args:
            request (ChatCompletionRequest): The chat completion request to process

        Returns:
            Optional[tuple[str, int]]: A tuple containing the message content and
                                       its index, or None if no user message is found
        """
        if request.get("messages") is None:
            return None
        for i in reversed(range(len(request["messages"]))):
            if request["messages"][i]["role"] == "user":
                content = request["messages"][i]["content"]

                # This is really another LiteLLM weirdness. Depending on the
                # provider inside the ChatCompletionRequest you might either
                # have a string or a list of Union, one of which is a
                # ChatCompletionTextObject. We'll handle this better by
                # either dumping litellm completely or converting to a more sane
                # format # in our own adapter

                # Handle string content
                if isinstance(content, str):
                    return content, i

                # Handle iterable of ChatCompletionTextObject
                if isinstance(content, (list, tuple)):
                    # Find first text content
                    for item in content:
                        if isinstance(item, dict) and item.get("type") == "text":
                            return item["text"], i

                    # If no text content found, return None
                    return None

        return None

    @abstractmethod
    async def process(
        self, request: ChatCompletionRequest, context: PipelineContext
    ) -> PipelineResult:
        """Process a request and return either modified request or response stream"""
        pass


class SequentialPipelineProcessor:
    def __init__(self, pipeline_steps: List[PipelineStep]):
        self.pipeline_steps = pipeline_steps

    async def process_request(
        self,
        request: ChatCompletionRequest,
    ) -> PipelineResult:
        """
        Process a request through all pipeline steps

        Args:
            request: The chat completion request to process

        Returns:
            PipelineResult containing either a modified request or response structure
        """
        context = PipelineContext()
        current_request = request

        for step in self.pipeline_steps:
            result = await step.process(current_request, context)
            if result is None:
                continue

            if result.shortcuts_processing():
                return result

            if result.request is not None:
                current_request = result.request

            if result.context is not None:
                context = result.context

        return PipelineResult(request=current_request, context=context)
